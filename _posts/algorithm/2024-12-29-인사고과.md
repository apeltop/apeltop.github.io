---
title: Lv3. 인사고과
author: sunshine@ptokos.com
categories: [ algorithm, programmers ]
---

## 인사고과

[프로그래머스 문제](https://school.programmers.co.kr/learn/courses/30/lessons/152995)

### 문제 설명

> 완호네 회사는 연말마다 1년 간의 인사고과에 따라 인센티브를 지급합니다. 각 사원마다 근무 태도 점수와 동료 평가 점수가 기록되어 있는데 만약 어떤 사원이 다른 임의의 사원보다 두 점수가 모두 낮은 경우가 한
> 번이라도 있다면 그 사원은 인센티브를 받지 못합니다. 그렇지 않은 사원들에 대해서는 두 점수의 합이 높은 순으로 석차를 내어 석차에 따라 인센티브가 차등 지급됩니다. 이때, 두 점수의 합이 동일한 사원들은
> 동석차이며, 동석차의 수만큼 다음 석차는 건너 뜁니다. 예를 들어 점수의 합이 가장 큰 사원이 2명이라면 1등이 2명이고 2등 없이 다음 석차는 3등부터입니다.
>
> 각 사원의 근무 태도 점수와 동료 평가 점수 목록 scores이 주어졌을 때, 완호의 석차를 return 하도록 solution 함수를 완성해주세요.

### 시각화

첫 번째 컬럼은 보기 좋기 위해 index 를 붙인 것이다.

두 번째, 세 번째 컬럼은 각각 근무 태도 점수와 동료 평가 점수이다.

![인사고과-1.png](/assets/img/algorithm/인사고과-1.png)

첫 번째 행은 완호의 점수이다. 이 점수를 기준으로 다른 사원들과 비교를 하면 된다.
그럼 다른 사원들과 비교했을 때 3등에 위치하는 것을 알 수 있다.

![인사고과-2.png](/assets/img/algorithm/인사고과-2.png)

### 문제 해결 과정

이 문제의 경우 정렬을 사용하면 쉽게 해결할 수 있다.
1번 째 열을 기준으로 내림차순 정렬을 하고 2번 째 열을 기준으로 오름차순 정렬을 하면 된다.

이와 같이 정렬을 하는 이유는 사원의 점수가 다른 한 사원의 점수 모두 낮다면 인센티브를 받지 못하기 때문이다.
이를 구하기 위해 하나의 값으로 정렬을 하면 현재 사원보다 뒤에 있는 사원의 점수가 모두 낮은지 확인할 수 있다.

그러므로 두 개의 점수 중에서 하나의 점수는 정렬로 해결이 된 것이다. 무조건 뒤에 있는 점수는 같거나 낮기 때문이다.
그럼 이제 신경 쓸 점수는 하나만 남았다. 그것은 두 번째 열에 있는 점수이다.
이 점수는 max 값으로 계속 갱신해주면서 현재 사원의 점수와 비교하면 된다.
이유는 현재 사원이 max 값보다 작으면 무조건 인센티브를 받을 수 없기 때문이다. 그러기에 두 번째 열을 오름차순으로 정렬을 한 것이다.

점수가 아래와 같이 주어졌다고 가정을 해보자.

- [1 ,4]
- [3, 3]
- [4, 3]
- [4, 4]
- [3, 2]

![인사고과-3.png](/assets/img/algorithm/인사고과-3.png)

첫 번째 행은 완호의 점수이기 때문에 따로 저장을 해두고 구해야할 사원 목록에서는 지운다.

![인사고과-4.png](/assets/img/algorithm/인사고과-4.png)

이제 정렬을 하면 아래와 같이 정렬이 된다.

![인사고과-5.png](/assets/img/algorithm/인사고과-5.png)

두 번째 열의 값 max 를 갱신하면 아래와 같이 가능해진다.
첫 번째 열을 지운 이유는 정렬을 통해 실질적으로 비교할 것은 두 번째 열이기 때문이다.
물론 두 번째 열이 max 보다 같거나 클 경우 합을 통해 완효와 점수 비교를 해야한다.

1, 2, 3, 4 진행될 때를 보면 max 보다 값이 같거나 큰 경우는 파란 색으로 표시하였고 작은 경우는 빨간 색으로 표시하였다.

![인사고과-6.png](/assets/img/algorithm/인사고과-6.png)

### 전체 코드

위 내용을 코드로 구현하면 아래와 같다.

```python
def solution(scores):
    answer = 1

    wanho, wanho_sum = scores[0], sum(scores[0])
    max_r = 0
    for score in sorted(scores[1:], key=lambda x: (-x[0], x[1])):
        if wanho[0] < score[0] and wanho[1] < score[1]:
            return -1

        if score[1] < max_r:
            continue

        if sum(score) > wanho_sum:
            answer += 1
        max_r = score[1]

    return answer
```

![인사고과-7.png](/assets/img/algorithm/인사고과-7.png)

